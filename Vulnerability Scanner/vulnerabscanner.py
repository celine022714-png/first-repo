#DISCLAIMER# ONLY SCAN NETWORKS THAT YOU OWN OR HAVE PERMISSION TO SCAN.



import socket #Imports python socket library. Used to create network connections (TCP).
import ssl #Import SSL/TLS support. Used for encrypted connections. Allows banner grabbing from securing services.
from urllib.parse import urlparse  #Imports url parse function. Used to extract hostnam, scheme, and port from URLs.
import requests  #Imports the requests library. Often HTTP/HTTPS requests.


class portscan:  #Defines a class named portscan. A class groups which are Data(target, ports), Behavior (scan logic).
    def __init__(self, target, ports): #This runs when the object is created
        # target: string IP or hostname  #Comment explaining target
        # ports: list of ints, e.g. [80, 443, 8000]  #Comment explaining ports
        self.target = target  #Saves the target into the object
        self.ports = ports  #stores the list of ports to scan
        self.open_ports = [] #Initializes an empty list. will store ports are open.
        self.banners = [] #Initializes an empty list

    def scan(self): #Defines the scan () function
        print(f"\nScanning {self.target} on ports {self.ports}...\n")  #Prints scan information for the user

        for port in self.ports:  #Loops through every port in the list
            try: #Starts a try block. Prevents crashes if a port fails or times out.
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:  #Creates a TCP socket
                    s.settimeout(1.0)  #Sets a 1-second timeout. Prevents hanging on unresponsive ports.
                    result = s.connect_ex((self.target, port)) #Attempts to connect (Ip, port)

                    if result == 0: #Checks if the connection succeeded 
                        self.open_ports.append(port)  #Adds the open port to open_ports list
                        print(f"[+] Port {port} is OPEN on {self.target}") #Displays open port to the user

                        banner = ""  #Initializes an empty string. Will store service banner text.
                        try:  #Starts another try block
                            # For web-ish ports, send a simple HTTP request
                            if port in (80, 443, 8000, 8080):  #Checks if the port is commonly used for web services. Limits HTTP requests to appropriate ports.
                                s.sendall(b"HEAD / HTTP/1.0\r\n\r\n")  #sends a raw HTTP request over the socket.
                            # Try to read one chunk
                            data = s.recv(1024)  #Reads up to 1024 bytes from the socket (server response)
                            if data:
                                banner = data.decode(errors="ignore").strip() #Converts raw bytes into a string.
                        except Exception:  #If anything goes wrong in that banner grabbing block (bad response, decode issue, etc.)
                            banner = ""    #Sets a banner to empty string so your program doesnt crash and can continue scanning.

                        if banner:   #Only run the next lines if banner is not empty
                            self.banners.append(banner)  #Adds this banner text to your list slef.banners
                            print(f"    [DEBUG] Banner: {repr(banner)}")  #Prints banner in debug mode
            except Exception:  #This is likely the outer try/except for the whole port scan attempt. Catches connection failures/timeouts etc.
                # ignore connection failures / timeouts
                pass #Do nothing

# ---------------------------
# Settings / common data
# ---------------------------

COMMON_PORTS = {   #Creates a dictionary (key-value pairs)
    21: "FTP",
    22: "SSH",
    23: "Telnet",
    25: "SMTP",
    53: "DNS",
    80: "HTTP",
    110: "POP3",
    143: "IMAP",
    443: "HTTPS",
    3389: "RDP",
}   #Ends the Dictionary


# ---------------------------
# Network / port scanning
# ---------------------------

def scan_port(host: str, port: int, timeout: float = 1.0) -> bool:
    """
    Try to connect to a TCP port.
    Returns True if connection succeeded (port appears open).
    """
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.settimeout(timeout)
        try:
            result = s.connect_ex((host, port))
            return result == 0
        except socket.error:
            return False


def grab_banner(host: str, port: int, timeout: float = 1.0) -> str:
    """
    Try to read a simple banner from an open port.
    This often reveals server software and version.
    """
    banner = ""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.settimeout(timeout)
        try:
            s.connect((host, port))
            # Send a simple request for some common protocols
            if port in (80, 443):
                s.sendall(b"HEAD / HTTP/1.0\r\n\r\n")
            else:
                s.sendall(b"\r\n")

            try:
                banner = s.recv(1024).decode(errors="ignore")
            except socket.timeout:
                banner = ""
        except Exception:
            banner = ""
    return banner.strip()


def analyze_port_findings(port: int, banner: str) -> list[str]:
    """
    Give simple, generic observations per port.
    This does NOT exploit anything; just flags possible concerns.
    """
    issues = []
    service = COMMON_PORTS.get(port, "Unknown")

    # Generic issue: banner reveals versions
    if banner:
        issues.append(
            f"Port {port} ({service}) is leaking banner info: {banner.splitlines()[0][:80]}"
        )

    # Very generic notes per service
    if port == 21:
        issues.append("FTP is cleartext; consider using SFTP/FTPS instead.")
    elif port == 22:
        issues.append("Ensure SSH uses strong passwords/keys and disables root login.")
    elif port == 23:
        issues.append("Telnet is insecure (cleartext). Consider disabling it.")
    elif port == 25:
        issues.append("SMTP exposed; ensure itâ€™s not an open relay.")
    elif port == 80:
        issues.append("HTTP without HTTPS; consider redirecting to HTTPS only.")
    elif port == 443:
        issues.append("Check TLS configuration (protocols/ciphers) with specialized tools.")
    elif port == 3389:
        issues.append("RDP exposed; restrict by firewall/VPN and use strong passwords.")
    elif port == 53:
        issues.append("DNS exposed; ensure itâ€™s not an open resolver.")
    elif port in (110, 143):
        issues.append(f"{service} is cleartext; consider using secure alternatives (e.g. IMAPS, POP3S).")
    return issues


def scan_network_host(host: str, ports: list[int]) -> dict:
    """
    Scan host for open ports and collect banner + basic comments.
    Returns summary dictionary.
    """
    result = {
        "host": host,
        "open_ports": [],
        "issues": []
    }

    print("=== Network / Port Scan ===")
    print(f"Target host: {host}")
    print(f"Ports: {ports}\n")

    for port in ports:
        if scan_port(host, port):
            service = COMMON_PORTS.get(port, "Unknown")
            print(f"[+] {port}/tcp OPEN ({service})")
            banner = grab_banner(host, port)
            if banner:
                print(f"    Banner: {banner.splitlines()[0][:80]}")
            else:
                print(f"    Banner: <no banner>")

            result["open_ports"].append((port, service, banner))
            result["issues"].extend(analyze_port_findings(port, banner))
        else:
            print(f"[-] {port}/tcp closed or filtered")

    return result


# ---------------------------
# Web / HTTP checks
# ---------------------------

def normalize_url(target: str) -> str:
    if target.startswith(("http://", "https://")):
        return target
    # Default to http, we will see if it redirects to https
    return "http://" + target


def check_tls_cert(host: str, port: int = 443, timeout: float = 3.0) -> dict:
    """
    Try to grab TLS certificate info from a host:port.
    """
    info = {
        "cert_subject": None,
        "cert_issuer": None,
        "error": None
    }

    context = ssl.create_default_context()
    with socket.create_connection((host, port), timeout=timeout) as sock:
        with context.wrap_socket(sock, server_hostname=host) as ssock:
            cert = ssock.getpeercert()
            info["cert_subject"] = dict(x[0] for x in cert.get("subject", []))
            info["cert_issuer"] = dict(x[0] for x in cert.get("issuer", []))
    return info


def scan_web_target(url: str) -> dict:
    """
    Perform simple 'vulnerability-style' checks on a web app:
    - HTTPS / redirect behavior
    - Security headers
    - Cookie flags
    - Basic TLS cert info
    """
    url = normalize_url(url)
    parsed = urlparse(url)

    result = {
        "url": url,
        "final_url": None,
        "status_code": None,
        "https": False,
        "headers": {},
        "cookies": [],
        "tls_info": None,
        "issues": []
    }

    print("\n=== Web / HTTP Scan ===")
    print(f"Target URL: {url}")

    try:
        resp = requests.get(url, allow_redirects=True, timeout=5)
    except requests.RequestException as e:
        print(f"[!] Error fetching {url}: {e}")
        result["issues"].append(f"Could not fetch URL: {e}")
        return result

    result["final_url"] = resp.url
    result["status_code"] = resp.status_code
    result["headers"] = dict(resp.headers)
    result["cookies"] = resp.cookies

    print(f"Final URL: {resp.url}")
    print(f"HTTP status: {resp.status_code}")

    final_parsed = urlparse(resp.url)
    if final_parsed.scheme == "https":
        result["https"] = True
        print("[+] HTTPS in use at final URL")
    else:
        print("[!] Final URL is not HTTPS (no TLS).")
        result["issues"].append("Site does not enforce HTTPS at final URL.")

    # Check security headers
    security_headers = {
        "Strict-Transport-Security": "Enforces HTTPS and helps prevent downgrade attacks.",
        "Content-Security-Policy": "Helps mitigate XSS and injection.",
        "X-Frame-Options": "Helps prevent clickjacking.",
        "X-Content-Type-Options": "Prevents MIME-type sniffing.",
        "Referrer-Policy": "Controls referrer information leakage.",
        "Permissions-Policy": "Controls access to powerful browser features."
    }

    print("\nSecurity headers:")
    for h, desc in security_headers.items():
        if h in resp.headers:
            print(f"[+] {h}: PRESENT   -> {desc}")
        else:
            print(f"[!] {h}: MISSING   -> {desc}")
            result["issues"].append(f"Missing security header: {h}")

    # Info leakage from Server / X-Powered-By
    server_header = resp.headers.get("Server")
    if server_header:
        print(f"\n[!] Server header present: {server_header}")
        result["issues"].append(
            f"Server header reveals info: {server_header} (information leakage)."
        )

    powered_by = resp.headers.get("X-Powered-By")
    if powered_by:
        print(f"[!] X-Powered-By header present: {powered_by}")
        result["issues"].append(
            f"X-Powered-By header reveals tech stack: {powered_by} (information leakage)."
        )

    # Cookie flags
    print("\nCookies:")
    if not resp.cookies:
        print("No cookies set.")
    for c in resp.cookies:
        secure = c.secure
        http_only = "HttpOnly" in c._rest.keys() if hasattr(c, "_rest") else False
        print(f"- {c.name}: Secure={secure}, HttpOnly={http_only}")
        if not secure and result["https"]:
            result["issues"].append(f"Cookie '{c.name}' not marked Secure over HTTPS.")
        if not http_only:
            result["issues"].append(f"Cookie '{c.name}' not marked HttpOnly.")

    # TLS certificate info (if HTTPS)
    if result["https"]:
        try:
            tls_info = check_tls_cert(final_parsed.hostname, final_parsed.port or 443)
            result["tls_info"] = tls_info
            subj = tls_info.get("cert_subject")
            issuer = tls_info.get("cert_issuer")
            print("\nTLS certificate info:")
            if subj:
                print(f"  Subject: {subj}")
            if issuer:
                print(f"  Issuer:  {issuer}")
        except Exception as e:
            print(f"[!] Could not retrieve TLS certificate info: {e}")
            result["issues"].append(f"Could not retrieve TLS certificate: {e}")

    return result


# ---------------------------
# Main / CLI
# ---------------------------

def main():
    # ðŸ”§ CHANGE THESE TWO VALUES TO WHATEVER YOU WANT TO SCAN
    host = "192.168.0.140"   # your own machine / target
    ports = [21,22,23,25,53,80,110,143,443,3389,8000]    # list of ports you want to scan

    print(f"Scanning {host} on ports {ports}...\n")

    for port in ports:
        is_open = scan_port(host, port)
        if is_open:
            print(f"[+] Port {port} is OPEN on {host}")
        else:
            print(f"[-] Port {port} is CLOSED or FILTERED on {host}")

if __name__ == "__main__":

    main()

